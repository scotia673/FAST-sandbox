import { contrastRatio, isColorStringHexRGB, isColorStringWebRGB, parseColorHexRGB, parseColorWebRGB, rgbToRelativeLuminance, } from "@microsoft/fast-colors";
import { memoize } from "lodash-es";
/**
 * The states that a swatch can have
 * @internal
 */
export var SwatchFamilyType;
(function (SwatchFamilyType) {
    SwatchFamilyType["rest"] = "rest";
    SwatchFamilyType["hover"] = "hover";
    SwatchFamilyType["active"] = "active";
    SwatchFamilyType["focus"] = "focus";
    SwatchFamilyType["selected"] = "selected";
})(SwatchFamilyType || (SwatchFamilyType = {}));
/**
 * @internal
 */
export function colorRecipeFactory(recipe) {
    const memoizedRecipe = memoize(recipe);
    function curryRecipe(arg) {
        if (typeof arg === "function" || typeof arg === "string") {
            return (designSystem) => {
                return memoizedRecipe(Object.assign({}, designSystem, {
                    backgroundColor: typeof arg === "function" ? arg(designSystem) : arg,
                }));
            };
        }
        else {
            return memoizedRecipe(arg);
        }
    }
    return curryRecipe;
}
/**
 * Helper function to transform a SwatchFamilyResolver into simple ColorRecipe for simple use
 * use in stylesheets.
 *
 * @internal
 */
export function swatchFamilyToSwatchRecipeFactory(type, callback) {
    const memoizedRecipe = memoize(callback);
    return (arg) => {
        if (typeof arg === "function" || typeof arg === "string") {
            return (designSystem) => {
                return memoizedRecipe(Object.assign({}, designSystem, {
                    backgroundColor: typeof arg === "function" ? arg(designSystem) : arg,
                }))[type];
            };
        }
        else {
            return memoizedRecipe(arg)[type];
        }
    };
}
/**
 * Converts a color string into a ColorRGBA64 instance.
 * Supports #RRGGBB and rgb(r, g, b) formats
 *
 * @public
 */
export const parseColorString = memoize((color) => {
    let parsed = parseColorHexRGB(color);
    if (parsed !== null) {
        return parsed;
    }
    parsed = parseColorWebRGB(color);
    if (parsed !== null) {
        return parsed;
    }
    throw new Error(`${color} cannot be converted to a ColorRGBA64. Color strings must be one of the following formats: "#RGB", "#RRGGBB", or "rgb(r, g, b)"`);
});
/**
 * Determines if a string value represents a color
 * Supports #RRGGBB and rgb(r, g, b) formats
 * @internal
 */
export function isValidColor(color) {
    return isColorStringHexRGB(color) || isColorStringWebRGB(color);
}
/**
 * Determines if a color string matches another color.
 * Supports #RRGGBB and rgb(r, g, b) formats
 * @internal
 */
export function colorMatches(a, b) {
    return parseColorString(a).equalValue(parseColorString(b));
}
/**
 * Returns the contrast value between two color strings.
 * Supports #RRGGBB and rgb(r, g, b) formats.
 * @internal
 */
export const contrast = memoize((a, b) => {
    return contrastRatio(parseColorString(a), parseColorString(b));
}, (a, b) => a + b);
/**
 * Returns the relative luminance of a color. If the value is not a color, -1 will be returned
 * Supports #RRGGBB and rgb(r, g, b) formats
 * @internal
 */
export function luminance(color) {
    return rgbToRelativeLuminance(parseColorString(color));
}
/**
 * @internal
 */
export function designSystemResolverMax(...args) {
    return (designSystem) => Math.max.apply(null, args.map((fn) => fn(designSystem)));
}
/**
 * @internal
 */
export const clamp = (value, min, max) => Math.min(Math.max(value, min), max);
